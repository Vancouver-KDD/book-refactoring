CHAPTER 7: DESIGN A UNIQUE ID GENERATOR IN DISTRIBUTED SYSTEMS

auto_increment does not work in a distributed environment
- single database server is not large enough
- generating unique IDs across multiple databases with minimal delay is challenging.

Unique + sortable + increment by 1? - not necessary, just increment
 or order by date + only numerical values? + ID length? 64-bit
Scale of system = generate 10,000 IDs per second

1. Multi-master replication
2. Universally unique identifier (UUID)
3. Ticket server
4. Twitter snowflake approach

1. Multi-master replication
- Increase by k (number of db servers)
- Next ID = previous ID + plus 2 in same server (1, 3, 5.. or 2, 4, 6…)
- Can scale with number of database servers
- BUT, hard to. Scale with multiple data centres + IDs do not go up with time across servers
- Does not scale when server is added or removed

2. Universally unique identifier (UUID)
- 128-bit number - very low probability of getting collusion
- Each web server can contain ID generator
- Simple + no synchronization issue + easy to scale
- BUT, 128 bits is long, our requirement is 64bits
- IDs do not go up in time and can be non-numeric

3. Ticket server
- Centralized auto-increment feature in a single database server
- Numeric and easy to implement, works for small to medium scale applications
- BUT, single point of failure. - multiple ticket servers -> new data sync challenges

4. Twitter snowflake approach
- Divide and conquer
- Single bit -> always be 0 and reserved for future uses (signed/unsigned)
- Timestamp -> 41 bits - milliseconds since the epoch or custom epoch. 
- Datacenter ID - 5 bits (2^5 = 32 datacenters)
- Machine ID - 5 bits (2^5 = 32 machines per datacenter)
- Sequence number: 12 bits. Incremented by 1, reset to 0 every millisecond?

- Max timestamp = 41 bits
- 2 ^ 41 = ~ milliseconds = ~69 years



CHAPTER 8: DESIGN A URL SHORTENER

API endpoints:
1. URL redirecting: GET api/v1/shortUrl, return longURL for HTTP redirection
2. URL shortening: POST api/v2/data/shorten {param: {longUrl: longURLString}, return shortURL

Shortening: each longURL must be hashed to one hashValue.
Each hashValue can be mapped back to long URL

URL table: pk: id(auto increment), shortURL, longURL

Hash Function: hashValue = [0-9, a-z, A-Z] = 62 possible characters
62 ^ n >= 365 billion?

1. Hash + collision resolution - expensive to query the database to check if a shortURL exists for every request (Sol: bloom filter)

2. Base 62 conversion:
base 62 is a way of using 62 characters for encoding. The mappings are: 0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z, where ‘a’ stands for 10, ‘Z’ stands for 61, etc.
•1115710 =2x622 +55x621+59x620 =[2,55,59]->[2,T,X]inbase62

11157 % 62 = 59 -> X in base 62 representation 
169 % 62 = 55 -> T
2 % 62 = 2 -> 2 
0

Hash + Collision vs. Base 62 conversion
Fixed short URL length vs. Length increases with ID
Does not need unique ID generator vs. Depends on unique ID generator
Collision possible and must be resolved vs. Impossible
Impossible to figure out the next available short URL vs. Easy to figure out if ID increments by 1 (security issue)

URL shortening Summary:
1. longURL is the input. 2. The system checks if the longURL is in the database.
3. If it is, it means the longURL was converted to shortURL before. In this case, fetch the shortURL from the database and return it to the client.
4. If not, the longURL is new. A new unique ID (primary key) Is generated by the unique ID generator.
5. Convert the ID to shortURL with base 62 conversion.
6. Create a new database row with the ID, shortURL, and longURL.

URL redirecting Summary:
1. A user clicks a short URL link: https://tinyurl.com/zn9edcu
2. The load balancer forwards the request to web servers.
3. If a shortURL is already in the cache, return the longURL directly.
4. If a shortURL is not in the cache, fetch the longURL from the database. If it is not in the database, it is likely a user entered an invalid shortURL.
5. The longURL is returned to the user.


